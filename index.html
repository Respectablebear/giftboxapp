<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sharebear Box Designer</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the app container */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: #f3f4f6;
            font-family: 'Inter', sans-serif;
        }

        @media (min-width: 768px) {
            .app-container {
                flex-direction: row;
            }
        }
        
        /* Ensure the canvas fills the container */
        .canvas-container {
            flex: 1;
            width: 100%;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Hide scrollbars on mobile for a cleaner look */
        body {
            overflow: hidden;
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="root" class="app-container"></div>

    <!-- React and React-DOM from CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Three.js and OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/controls/OrbitControls.min.js"></script>

    <script type="text/babel">
        // Utility function to create a texture with ribbon and bow
        const createRibbonTexture = (size, ribbonColor) => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = size.width * 20;  
            canvas.height = size.height * 20;
            ctx.fillStyle = 'rgba(0,0,0,0)'; // Make background transparent
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw the vertical ribbon pattern
            ctx.fillStyle = ribbonColor;
            const ribbonWidth = canvas.width * 0.15;
            ctx.fillRect((canvas.width - ribbonWidth) / 2, 0, ribbonWidth, canvas.height);

            // Draw a simple bow knot
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height * 0.15, canvas.width * 0.05, 0, 2 * Math.PI);
            ctx.fillStyle = ribbonColor;
            ctx.fill();

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        };

        // Main App Component
        const App = () => {
            const canvasRef = React.useRef(null);
            const [isLidOpen, setIsLidOpen] = React.useState(false);
            const [paperMacheColor, setPaperMacheColor] = React.useState('#ffffff');
            const [ribbonVisible, setRibbonVisible] = React.useState(false);
            const [ribbonColor, setRibbonColor] = React.useState('#ffd700'); // Default to gold
            const [comments, setComments] = React.useState('');
            const [error, setError] = React.useState(null);
            
            // Define a map of colors for the paper mache and ribbon
            const paperMacheColorOptions = {
                pink: '#ffc0cb',
                white: '#ffffff',
                silver: '#c0c0c0',
                blue: '#add8e6',
                red: '#ff0000',
                yellow: '#ffff00',
                gold: '#ffd700'
            };

            const ribbonColorOptions = {
                white: '#ffffff',
                silver: '#c0c0c0',
                black: '#000000',
                red: '#ff0000',
                gold: '#ffd700',
                blue: '#0000ff',
                yellow: '#ffff00'
            };

            const sceneRef = React.useRef(null);
            const cameraRef = React.useRef(null);
            const rendererRef = React.useRef(null);
            const baseMeshRef = React.useRef(null);
            const lidMeshRef = React.useRef(null);
            const confettiGroupRef = React.useRef(new THREE.Group());
            const controlsRef = React.useRef(null);

            React.useEffect(() => {
                const initScene = () => {
                    try {
                        if (!canvasRef.current) {
                            return;
                        }

                        // --- Scene Setup ---
                        const scene = new THREE.Scene();
                        scene.background = new THREE.Color(0xcccccc); // Set a neutral gray background
                        sceneRef.current = scene;
                        scene.add(confettiGroupRef.current);

                        // --- Camera Setup ---
                        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                        camera.position.z = 50;
                        cameraRef.current = camera;

                        // --- Renderer Setup ---
                        const renderer = new THREE.WebGLRenderer({
                            canvas: canvasRef.current,
                            antialias: true,
                        });
                        renderer.setSize(window.innerWidth, window.innerHeight);
                        rendererRef.current = renderer;
                        renderer.shadowMap.enabled = true;
                        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                        // --- Lighting ---
                        const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
                        scene.add(ambientLight);
                        
                        const spotLight1 = new THREE.SpotLight(0xffffff, 2);
                        spotLight1.position.set(50, 50, 50);
                        spotLight1.angle = Math.PI / 8;
                        spotLight1.penumbra = 0.5;
                        spotLight1.castShadow = true;
                        scene.add(spotLight1);

                        const spotLight2 = new THREE.SpotLight(0xffffff, 2);
                        spotLight2.position.set(-50, 50, 50);
                        spotLight2.angle = Math.PI / 8;
                        spotLight2.penumbra = 0.5;
                        spotLight2.castShadow = true;
                        scene.add(spotLight2);

                        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
                        directionalLight.position.set(0, 50, 50);
                        scene.add(directionalLight);
                        
                        // --- Box Meshes ---
                        const boxSize = { width: 20, height: 20, depth: 20 };
                        const lidHeight = 3;
                        const lidOverlap = 1;
                        
                        // Base of the box
                        const outerBoxGeo = new THREE.BoxGeometry(boxSize.width, boxSize.height, boxSize.depth);
                        const outerBoxMaterial = new THREE.MeshStandardMaterial({ color: '#2d3748', metalness: 0.8, roughness: 0.2 });
                        const outerBoxMaterials = [
                            outerBoxMaterial,
                            outerBoxMaterial,
                            new THREE.MeshStandardMaterial({ color: '#2d3748', transparent: true, opacity: 0, metalness: 0.8, roughness: 0.2 }),
                            outerBoxMaterial,
                            outerBoxMaterial,
                            outerBoxMaterial
                        ];
                        baseMeshRef.current = new THREE.Mesh(outerBoxGeo, outerBoxMaterials);
                        baseMeshRef.current.castShadow = true;
                        baseMeshRef.current.receiveShadow = true;
                        scene.add(baseMeshRef.current);

                        // Inner walls for visual depth
                        const innerWallsGeo = new THREE.BoxGeometry(boxSize.width * 0.95, boxSize.height * 0.95, boxSize.depth * 0.95);
                        const innerWallsMaterial = new THREE.MeshBasicMaterial({ color: '#c0c0c0', side: THREE.BackSide });
                        const innerWalls = new THREE.Mesh(innerWallsGeo, innerWallsMaterial);
                        baseMeshRef.current.add(innerWalls);

                        // Inner edges for a border effect
                        const innerEdges = new THREE.EdgesGeometry(innerWallsGeo);
                        const innerLines = new THREE.LineSegments(innerEdges, new THREE.LineBasicMaterial({ color: 0x999999 }));
                        baseMeshRef.current.add(innerLines);

                        // Lid of the box
                        const lidGeometry = new THREE.BoxGeometry(boxSize.width + lidOverlap, lidHeight, boxSize.depth + lidOverlap);
                        const lidMaterial = new THREE.MeshStandardMaterial({ color: '#2d3748', metalness: 0.8, roughness: 0.2 });
                        const lidMaterials = [
                            lidMaterial, lidMaterial, lidMaterial, lidMaterial, lidMaterial, lidMaterial
                        ];
                        lidMeshRef.current = new THREE.Mesh(lidGeometry, lidMaterials);
                        lidMeshRef.current.position.y = (boxSize.height / 2) + (lidHeight / 2);
                        lidMeshRef.current.castShadow = true;
                        lidMeshRef.current.receiveShadow = true;
                        scene.add(lidMeshRef.current);
                        
                        // --- Orbit Controls ---
                        const controls = new OrbitControls(camera, renderer.domElement);
                        controlsRef.current = controls;

                        // --- Animation Loop ---
                        const animate = () => {
                            requestAnimationFrame(animate);
                            if (confettiGroupRef.current) {
                                confettiGroupRef.current.children.forEach(confetto => {
                                    confetto.position.y -= 0.1;
                                    confetto.rotation.x += Math.random() * 0.1;
                                    confetto.rotation.y += Math.random() * 0.1;
                                    // Reset confetti position when it falls below the box floor
                                    if (confetto.position.y < -boxSize.height / 2) {
                                        confetto.position.y = (boxSize.height / 2) - 1;
                                    }
                                });
                            }
                            controls.update();
                            renderer.render(scene, camera);
                        };
                        animate();

                        // --- Window Resize Handler ---
                        const handleResize = () => {
                            if (rendererRef.current && cameraRef.current) {
                                const width = window.innerWidth;
                                const height = window.innerHeight;
                                rendererRef.current.setSize(width, height);
                                cameraRef.current.aspect = width / height;
                                cameraRef.current.updateProjectionMatrix();
                            }
                        };

                        window.addEventListener('resize', handleResize);
                        // Cleanup function
                        return () => {
                            window.removeEventListener('resize', handleResize);
                            controls.dispose();
                            renderer.dispose();
                        };
                    } catch (e) {
                        // Catch any initialization errors and set an error state
                        console.error("Failed to initialize Three.js scene:", e);
                        setError("Failed to load the 3D environment. Please check the browser console for details.");
                    }
                };

                initScene();
            }, []);

            // Effect to handle lid and ribbon state changes
            React.useEffect(() => {
                if (!baseMeshRef.current || !lidMeshRef.current) return;

                const boxSize = { width: 20, height: 20, depth: 20 };
                const lidHeight = 3;
                const boxHeight = baseMeshRef.current.geometry.parameters.height;
                // Set the target Y position for the lid based on its state
                const targetY = isLidOpen ? (boxHeight / 2) + lidHeight + 10 : (boxHeight / 2) + (lidHeight / 2);
                lidMeshRef.current.position.y = targetY;

                // Update ribbon materials
                if (ribbonVisible) {
                    // Create and apply ribbon texture to lid
                    const ribbonTextureLid = createRibbonTexture(boxSize, ribbonColor);
                    const lidMaterialWithRibbon = new THREE.MeshStandardMaterial({ color: '#2d3748', map: ribbonTextureLid, metalness: 0.8, roughness: 0.2 });
                    
                    const lidMaterials = [...lidMeshRef.current.material];
                    lidMaterials[0] = lidMaterialWithRibbon;
                    lidMaterials[1] = lidMaterialWithRibbon;
                    lidMaterials[4] = lidMaterialWithRibbon;
                    lidMaterials[5] = lidMaterialWithRibbon;
                    
                    lidMeshRef.current.material = lidMaterials;
                    
                    // Create and apply ribbon texture to base
                    const ribbonTextureBase = createRibbonTexture(boxSize, ribbonColor);
                    const baseMaterialWithRibbon = new THREE.MeshStandardMaterial({ color: '#2d3748', map: ribbonTextureBase, metalness: 0.8, roughness: 0.2 });
                    const baseMaterials = [...baseMeshRef.current.material];
                    
                    baseMaterials[0] = baseMaterialWithRibbon;
                    baseMaterials[1] = baseMaterialWithRibbon;
                    baseMaterials[4] = baseMaterialWithRibbon;
                    baseMaterials[5] = baseMaterialWithRibbon;

                    baseMeshRef.current.material = baseMaterials;
                    
                } else {
                    // Revert to plain material without ribbon
                    const lidMaterial = new THREE.MeshStandardMaterial({ color: '#2d3748', metalness: 0.8, roughness: 0.2 });
                    lidMeshRef.current.material = [lidMaterial, lidMaterial, lidMaterial, lidMaterial, lidMaterial, lidMaterial];
                    const baseMaterial = new THREE.MeshStandardMaterial({ color: '#2d3748', metalness: 0.8, roughness: 0.2 });
                    const baseMaterials = [...baseMeshRef.current.material];
                    // Reset only the faces that would have a ribbon
                    baseMaterials[0] = baseMaterial;
                    baseMaterials[1] = baseMaterial;
                    baseMaterials[4] = baseMaterial;
                    baseMaterials[5] = baseMaterial;
                    // Also reset the top face, which is transparent
                    baseMaterials[2] = new THREE.MeshStandardMaterial({ color: '#2d3748', transparent: true, opacity: 0, metalness: 0.8, roughness: 0.2 });
                    baseMeshRef.current.material = baseMaterials;
                }
                
            }, [isLidOpen, ribbonVisible, ribbonColor]);

            // Function to add confetti-like paper mache to the box
            const addPaperMache = () => {
                if (!isLidOpen || !confettiGroupRef.current) return;
                const boxSize = { width: 20, height: 20, depth: 20 };
                const count = 50;
                // Clear existing confetti
                confettiGroupRef.current.children = [];
                for (let i = 0; i < count; i++) {
                    const paperMache = new THREE.Mesh(
                        new THREE.PlaneGeometry(1, 1),
                        new THREE.MeshBasicMaterial({ color: paperMacheColor })
                    );
                    // Position confetti randomly inside the box
                    paperMache.position.set(
                        (Math.random() - 0.5) * boxSize.width * 0.8,
                        (boxSize.height / 2) - 1,
                        (Math.random() - 0.5) * boxSize.depth * 0.8
                    );
                    // Give confetti a random initial rotation
                    paperMache.rotation.x = Math.random() * Math.PI;
                    paperMache.rotation.y = Math.random() * Math.PI;
                    confettiGroupRef.current.add(paperMache);
                }
            };

            return (
                <div className="flex flex-col md:flex-row h-screen bg-gray-100 font-sans">
                
                {/* Control Panel */}
                <div className="w-1/3 p-6 bg-white shadow-lg overflow-y-auto">
                    <h1 className="text-3xl font-bold mb-4 text-gray-800">Sharebear Box Designer</h1>
                    <p className="text-gray-600 mb-6">
                    A classic two-piece box with a removable lid.
                    </p>

                    {/* Box & Lid Controls */}
                    <div className="mb-6 p-4 border rounded-md shadow-sm bg-gray-50">
                    <h2 className="text-xl font-semibold mb-3 text-gray-700">Box & Lid</h2>
                    <button
                        onClick={() => setIsLidOpen(!isLidOpen)}
                        className="bg-gray-800 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-300 ease-in-out hover:bg-gray-700"
                    >
                        {isLidOpen ? 'Close Lid' : 'Open Lid'}
                    </button>
                    </div>
                    
                    {/* Box Contents Controls */}
                    <div className="mb-6 p-4 border rounded-md shadow-sm bg-gray-50">
                    <h2 className="text-xl font-semibold mb-3 text-gray-700">Box Contents</h2>
                    <div className="flex flex-col space-y-3">
                        <label className="flex flex-col">
                        <span className="text-gray-600 font-medium mb-1">Paper Mache Color:</span>
                        <select
                            value={paperMacheColor}
                            onChange={(e) => setPaperMacheColor(e.target.value)}
                            className="w-full p-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-gray-800"
                        >
                            {Object.entries(paperMacheColorOptions).map(([name, hex]) => (
                            <option key={name} value={hex}>
                                {name.charAt(0).toUpperCase() + name.slice(1)}
                            </option>
                            ))}
                        </select>
                        </label>
                        <button
                        onClick={addPaperMache}
                        className="bg-gray-800 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-300 ease-in-out hover:bg-gray-700"
                        >
                        Add Paper Mache
                        </button>
                    </div>
                    </div>

                    {/* Ribbon & Bow Controls */}
                    <div className="mb-6 p-4 border rounded-md shadow-sm bg-gray-50">
                    <h2 className="text-xl font-semibold mb-3 text-gray-700">Ribbon & Bow</h2>
                    <div className="flex flex-col space-y-3">
                        <label className="flex items-center space-x-2">
                        <input
                            type="checkbox"
                            checked={ribbonVisible}
                            onChange={(e) => setRibbonVisible(e.target.checked)}
                            className="form-checkbox h-5 w-5 text-gray-800"
                        />
                        <span className="text-gray-600">Show Ribbon</span>
                        </label>
                        {ribbonVisible && (
                        <label className="flex flex-col">
                            <span className="text-gray-600 font-medium mb-1">Ribbon Color:</span>
                            <select
                            value={ribbonColor}
                            onChange={(e) => setRibbonColor(e.target.value)}
                            className="w-full p-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-gray-800"
                            >
                            {Object.entries(ribbonColorOptions).map(([name, hex]) => (
                                <option key={name} value={hex}>
                                {name.charAt(0).toUpperCase() + name.slice(1)}
                                </option>
                            ))}
                            </select>
                        </label>
                        )}
                    </div>
                    </div>
                    
                    {/* Message Input */}
                    <div className="mb-6 p-4 border rounded-md shadow-sm bg-gray-50">
                    <h2 className="text-xl font-semibold mb-3 text-gray-700">Message</h2>
                    <textarea
                        value={comments}
                        onChange={(e) => setComments(e.target.value)}
                        placeholder="What would you like your messsage to say..."
                        className="w-full p-2 border rounded-md h-24 focus:outline-none focus:ring-2 focus:ring-gray-800"
                    />
                    </div>
                </div>
                
                {/* Three.js Canvas or Error Message */}
                <div className="flex-1 w-full h-screen relative overflow-hidden">
                    {error ? (
                        <div className="error-message">
                            <h2 className="text-2xl font-bold text-red-600">Error</h2>
                            <p className="text-gray-700 mt-2">{error}</p>
                            <p className="text-gray-500 text-sm mt-4">For more details, please check the browser's developer console (F12).</p>
                        </div>
                    ) : (
                        <canvas ref={canvasRef} className="w-full h-full block" />
                    )}
                </div>
                
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>
</body>
</html>
