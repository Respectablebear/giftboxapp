import React, { useRef, useEffect, useState } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

// Utility function to create a texture with ribbon and bow
const createRibbonTexture = (size, ribbonColor) => {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  canvas.width = size.width * 20;  
  canvas.height = size.height * 20;
  ctx.fillStyle = 'rgba(0,0,0,0)'; // Make background transparent
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw the vertical ribbon pattern
  ctx.fillStyle = ribbonColor;
  const ribbonWidth = canvas.width * 0.15;
  ctx.fillRect((canvas.width - ribbonWidth) / 2, 0, ribbonWidth, canvas.height);

  // Draw a simple bow knot
  ctx.beginPath();
  ctx.arc(canvas.width / 2, canvas.height * 0.15, canvas.width * 0.05, 0, 2 * Math.PI);
  ctx.fillStyle = ribbonColor;
  ctx.fill();

  const texture = new THREE.CanvasTexture(canvas);
  return texture;
};

// Main App Component
const App = () => {
  const canvasRef = useRef(null);
  const [isLidOpen, setIsLidOpen] = useState(false);
  const [paperMacheColor, setPaperMacheColor] = useState('#ffffff');
  const [ribbonVisible, setRibbonVisible] = useState(false);
  const [ribbonColor, setRibbonColor] = useState('#ffd700'); // Default to gold
  const [comments, setComments] = useState('');
  
  // Define a map of colors for the paper mache and ribbon
  const paperMacheColorOptions = {
    pink: '#ffc0cb',
    white: '#ffffff',
    silver: '#c0c0c0',
    blue: '#add8e6',
    red: '#ff0000',
    yellow: '#ffff00',
    gold: '#ffd700'
  };

  const ribbonColorOptions = {
    white: '#ffffff',
    silver: '#c0c0c0',
    black: '#000000',
    red: '#ff0000',
    gold: '#ffd700',
    blue: '#0000ff',
    yellow: '#ffff00'
  };

  const sceneRef = useRef(null);
  const cameraRef = useRef(null);
  const rendererRef = useRef(null);
  const baseMeshRef = useRef(null);
  const lidMeshRef = useRef(null);
  const confettiGroupRef = useRef(new THREE.Group());
  const controlsRef = useRef(null);

  useEffect(() => {
    // --- Scene Setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xcccccc); // Set a neutral gray background
    sceneRef.current = scene;
    scene.add(confettiGroupRef.current);

    // --- Camera Setup ---
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 50;
    cameraRef.current = camera;

    // --- Renderer Setup ---
    const renderer = new THREE.WebGLRenderer({
      canvas: canvasRef.current,
      antialias: true,
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    rendererRef.current = renderer;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // --- Lighting ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
    scene.add(ambientLight);
    
    const spotLight1 = new THREE.SpotLight(0xffffff, 2);
    spotLight1.position.set(50, 50, 50);
    spotLight1.angle = Math.PI / 8;
    spotLight1.penumbra = 0.5;
    spotLight1.castShadow = true;
    scene.add(spotLight1);

    const spotLight2 = new THREE.SpotLight(0xffffff, 2);
    spotLight2.position.set(-50, 50, 50);
    spotLight2.angle = Math.PI / 8;
    spotLight2.penumbra = 0.5;
    spotLight2.castShadow = true;
    scene.add(spotLight2);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
    directionalLight.position.set(0, 50, 50);
    scene.add(directionalLight);
    
    // --- Box Meshes ---
    const boxSize = { width: 20, height: 20, depth: 20 };
    const lidHeight = 3;
    const lidOverlap = 1;
    
    // Base of the box
    const outerBoxGeo = new THREE.BoxGeometry(boxSize.width, boxSize.height, boxSize.depth);
    const outerBoxMaterial = new THREE.MeshStandardMaterial({ color: '#2d3748', metalness: 0.8, roughness: 0.2 });
    const outerBoxMaterials = [
      outerBoxMaterial,
      outerBoxMaterial,
      new THREE.MeshStandardMaterial({ color: '#2d3748', transparent: true, opacity: 0, metalness: 0.8, roughness: 0.2 }),
      outerBoxMaterial,
      outerBoxMaterial,
      outerBoxMaterial
    ];
    baseMeshRef.current = new THREE.Mesh(outerBoxGeo, outerBoxMaterials);
    baseMeshRef.current.castShadow = true;
    baseMeshRef.current.receiveShadow = true;
    scene.add(baseMeshRef.current);

    // Inner walls for visual depth
    const innerWallsGeo = new THREE.BoxGeometry(boxSize.width * 0.95, boxSize.height * 0.95, boxSize.depth * 0.95);
    const innerWallsMaterial = new THREE.MeshBasicMaterial({ color: '#c0c0c0', side: THREE.BackSide });
    const innerWalls = new THREE.Mesh(innerWallsGeo, innerWallsMaterial);
    baseMeshRef.current.add(innerWalls);

    // Inner edges for a border effect
    const innerEdges = new THREE.EdgesGeometry(innerWallsGeo);
    const innerLines = new THREE.LineSegments(innerEdges, new THREE.LineBasicMaterial({ color: 0x999999 }));
    baseMeshRef.current.add(innerLines);

    // Lid of the box
    const lidGeometry = new THREE.BoxGeometry(boxSize.width + lidOverlap, lidHeight, boxSize.depth + lidOverlap);
    const lidMaterial = new THREE.MeshStandardMaterial({ color: '#2d3748', metalness: 0.8, roughness: 0.2 });
    const lidMaterials = [
      lidMaterial, lidMaterial, lidMaterial, lidMaterial, lidMaterial, lidMaterial
    ];
    lidMeshRef.current = new THREE.Mesh(lidGeometry, lidMaterials);
    lidMeshRef.current.position.y = (boxSize.height / 2) + (lidHeight / 2);
    lidMeshRef.current.castShadow = true;
    lidMeshRef.current.receiveShadow = true;
    scene.add(lidMeshRef.current);
    
    // --- Orbit Controls ---
    const controls = new OrbitControls(camera, renderer.domElement);
    controlsRef.current = controls;

    // --- Animation Loop ---
    const animate = () => {
      requestAnimationFrame(animate);
      if (confettiGroupRef.current) {
        confettiGroupRef.current.children.forEach(confetto => {
          confetto.position.y -= 0.1;
          confetto.rotation.x += Math.random() * 0.1;
          confetto.rotation.y += Math.random() * 0.1;
          // Reset confetti position when it falls below the box floor
          if (confetto.position.y < -boxSize.height / 2) {
             confetto.position.y = (boxSize.height / 2) - 1;
          }
        });
      }
      controls.update();
      renderer.render(scene, camera);
    };
    animate();

    // --- Window Resize Handler ---
    const handleResize = () => {
      if (rendererRef.current && cameraRef.current) {
        const width = window.innerWidth;
        const height = window.innerHeight;
        rendererRef.current.setSize(width, height);
        cameraRef.current.aspect = width / height;
        cameraRef.current.updateProjectionMatrix();
      }
    };

    window.addEventListener('resize', handleResize);
    // Cleanup function
    return () => {
      window.removeEventListener('resize', handleResize);
      controls.dispose();
      renderer.dispose();
    };
  }, []);

  // Effect to handle lid and ribbon state changes
  useEffect(() => {
    if (!baseMeshRef.current || !lidMeshRef.current) return;

    const boxSize = { width: 20, height: 20, depth: 20 };
    const lidHeight = 3;
    const boxHeight = baseMeshRef.current.geometry.parameters.height;
    // Set the target Y position for the lid based on its state
    const targetY = isLidOpen ? (boxHeight / 2) + lidHeight + 10 : (boxHeight / 2) + (lidHeight / 2);
    lidMeshRef.current.position.y = targetY;

    // Update ribbon materials
    if (ribbonVisible) {
      // Create and apply ribbon texture to lid
      const ribbonTextureLid = createRibbonTexture(boxSize, ribbonColor);
      const lidMaterialWithRibbon = new THREE.MeshStandardMaterial({ color: '#2d3748', map: ribbonTextureLid, metalness: 0.8, roughness: 0.2 });
      
      const lidMaterials = [...lidMeshRef.current.material];
      lidMaterials[0] = lidMaterialWithRibbon;
      lidMaterials[1] = lidMaterialWithRibbon;
      lidMaterials[4] = lidMaterialWithRibbon;
      lidMaterials[5] = lidMaterialWithRibbon;
      
      lidMeshRef.current.material = lidMaterials;
      
      // Create and apply ribbon texture to base
      const ribbonTextureBase = createRibbonTexture(boxSize, ribbonColor);
      const baseMaterialWithRibbon = new THREE.MeshStandardMaterial({ color: '#2d3748', map: ribbonTextureBase, metalness: 0.8, roughness: 0.2 });
      const baseMaterials = [...baseMeshRef.current.material];
      
      baseMaterials[0] = baseMaterialWithRibbon;
      baseMaterials[1] = baseMaterialWithRibbon;
      baseMaterials[4] = baseMaterialWithRibbon;
      baseMaterials[5] = baseMaterialWithRibbon;

      baseMeshRef.current.material = baseMaterials;
      
    } else {
      // Revert to plain material without ribbon
      const lidMaterial = new THREE.MeshStandardMaterial({ color: '#2d3748', metalness: 0.8, roughness: 0.2 });
      lidMeshRef.current.material = [lidMaterial, lidMaterial, lidMaterial, lidMaterial, lidMaterial, lidMaterial];
      const baseMaterial = new THREE.MeshStandardMaterial({ color: '#2d3748', metalness: 0.8, roughness: 0.2 });
      const baseMaterials = [...baseMeshRef.current.material];
      // Reset only the faces that would have a ribbon
      baseMaterials[0] = baseMaterial;
      baseMaterials[1] = baseMaterial;
      baseMaterials[4] = baseMaterial;
      baseMaterials[5] = baseMaterial;
      // Also reset the top face, which is transparent
      baseMaterials[2] = new THREE.MeshStandardMaterial({ color: '#2d3748', transparent: true, opacity: 0, metalness: 0.8, roughness: 0.2 });
      baseMeshRef.current.material = baseMaterials;
    }
    
  }, [isLidOpen, ribbonVisible, ribbonColor]);

  // Function to add confetti-like paper mache to the box
  const addPaperMache = () => {
    if (!isLidOpen || !confettiGroupRef.current) return;
    const boxSize = { width: 20, height: 20, depth: 20 };
    const count = 50;
    // Clear existing confetti
    confettiGroupRef.current.children = [];
    for (let i = 0; i < count; i++) {
      const paperMache = new THREE.Mesh(
        new THREE.PlaneGeometry(1, 1),
        new THREE.MeshBasicMaterial({ color: paperMacheColor })
      );
      // Position confetti randomly inside the box
      paperMache.position.set(
        (Math.random() - 0.5) * boxSize.width * 0.8,
        (boxSize.height / 2) - 1,
        (Math.random() - 0.5) * boxSize.depth * 0.8
      );
      // Give confetti a random initial rotation
      paperMache.rotation.x = Math.random() * Math.PI;
      paperMache.rotation.y = Math.random() * Math.PI;
      confettiGroupRef.current.add(paperMache);
    }
  };

  return (
    <div className="flex flex-col md:flex-row h-screen bg-gray-100 font-sans">
      
      {/* Control Panel */}
      <div className="w-1/3 p-6 bg-white shadow-lg overflow-y-auto">
        <h1 className="text-3xl font-bold mb-4 text-gray-800">Sharebear Box Designer</h1>
        <p className="text-gray-600 mb-6">
          A classic two-piece box with a removable lid.
        </p>

        {/* Box & Lid Controls */}
        <div className="mb-6 p-4 border rounded-md shadow-sm bg-gray-50">
          <h2 className="text-xl font-semibold mb-3 text-gray-700">Box & Lid</h2>
          <button
            onClick={() => setIsLidOpen(!isLidOpen)}
            className="bg-gray-800 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-300 ease-in-out hover:bg-gray-700"
          >
            {isLidOpen ? 'Close Lid' : 'Open Lid'}
          </button>
        </div>
        
        {/* Box Contents Controls */}
        <div className="mb-6 p-4 border rounded-md shadow-sm bg-gray-50">
          <h2 className="text-xl font-semibold mb-3 text-gray-700">Box Contents</h2>
          <div className="flex flex-col space-y-3">
            <label className="flex flex-col">
              <span className="text-gray-600 font-medium mb-1">Paper Mache Color:</span>
              <select
                value={paperMacheColor}
                onChange={(e) => setPaperMacheColor(e.target.value)}
                className="w-full p-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-gray-800"
              >
                {Object.entries(paperMacheColorOptions).map(([name, hex]) => (
                  <option key={name} value={hex}>
                    {name.charAt(0).toUpperCase() + name.slice(1)}
                  </option>
                ))}
              </select>
            </label>
            <button
              onClick={addPaperMache}
              className="bg-gray-800 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-300 ease-in-out hover:bg-gray-700"
            >
              Add Paper Mache
            </button>
          </div>
        </div>

        {/* Ribbon & Bow Controls */}
        <div className="mb-6 p-4 border rounded-md shadow-sm bg-gray-50">
          <h2 className="text-xl font-semibold mb-3 text-gray-700">Ribbon & Bow</h2>
          <div className="flex flex-col space-y-3">
            <label className="flex items-center space-x-2">
              <input
                type="checkbox"
                checked={ribbonVisible}
                onChange={(e) => setRibbonVisible(e.target.checked)}
                className="form-checkbox h-5 w-5 text-gray-800"
              />
              <span className="text-gray-600">Show Ribbon</span>
            </label>
            {ribbonVisible && (
              <label className="flex flex-col">
                <span className="text-gray-600 font-medium mb-1">Ribbon Color:</span>
                <select
                  value={ribbonColor}
                  onChange={(e) => setRibbonColor(e.target.value)}
                  className="w-full p-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-gray-800"
                >
                  {Object.entries(ribbonColorOptions).map(([name, hex]) => (
                    <option key={name} value={hex}>
                      {name.charAt(0).toUpperCase() + name.slice(1)}
                    </option>
                  ))}
                </select>
              </label>
            )}
          </div>
        </div>
        
        {/* Message Input */}
        <div className="mb-6 p-4 border rounded-md shadow-sm bg-gray-50">
          <h2 className="text-xl font-semibold mb-3 text-gray-700">Message</h2>
          <textarea
            value={comments}
            onChange={(e) => setComments(e.target.value)}
            placeholder="What would you like your messsage to say..."
            className="w-full p-2 border rounded-md h-24 focus:outline-none focus:ring-2 focus:ring-gray-800"
          />
        </div>
      </div>
      
      {/* Three.js Canvas */}
      <div className="flex-1 w-full h-screen relative overflow-hidden">
        <canvas ref={canvasRef} className="w-full h-full block" />
      </div>
      
    </div>
  );
};

export default App;
